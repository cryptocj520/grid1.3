"""
ç½‘æ ¼äº¤æ˜“ç³»ç»Ÿåè°ƒå™¨

æ ¸å¿ƒåè°ƒé€»è¾‘ï¼š
1. åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ
2. å¤„ç†è®¢å•æˆäº¤äº‹ä»¶
3. è‡ªåŠ¨æŒ‚åå‘è®¢å•
4. å¼‚å¸¸å¤„ç†å’Œæš‚åœæ¢å¤
"""

import asyncio
from typing import Any, Dict, List, Optional
from decimal import Decimal
from datetime import datetime

from ....logging import get_logger
from ..interfaces import IGridStrategy, IGridEngine, IPositionTracker
from ..models import (
    GridConfig, GridState, GridOrder, GridOrderSide,
    GridOrderStatus, GridStatus, GridStatistics
)
from ..scalping import ScalpingManager
from ..capital_protection import CapitalProtectionManager
from ..take_profit import TakeProfitManager
from ..price_lock import PriceLockManager


class GridCoordinator:
    """
    ç½‘æ ¼äº¤æ˜“ç³»ç»Ÿåè°ƒå™¨
    
    èŒè´£ï¼š
    1. æ•´åˆç­–ç•¥ã€å¼•æ“ã€è·Ÿè¸ªå™¨
    2. è®¢å•æˆäº¤åçš„åå‘æŒ‚å•é€»è¾‘
    3. æ‰¹é‡æˆäº¤å¤„ç†
    4. ç³»ç»ŸçŠ¶æ€ç®¡ç†
    5. å¼‚å¸¸å¤„ç†
    """
    
    def __init__(
        self,
        config: GridConfig,
        strategy: IGridStrategy,
        engine: IGridEngine,
        tracker: IPositionTracker,
        grid_state: GridState
    ):
        """
        åˆå§‹åŒ–åè°ƒå™¨
        
        Args:
            config: ç½‘æ ¼é…ç½®
            strategy: ç½‘æ ¼ç­–ç•¥
            engine: æ‰§è¡Œå¼•æ“
            tracker: æŒä»“è·Ÿè¸ªå™¨
            grid_state: ç½‘æ ¼çŠ¶æ€ï¼ˆå…±äº«å®ä¾‹ï¼‰
        """
        self.logger = get_logger(__name__)
        self.config = config
        self.strategy = strategy
        self.engine = engine
        self.tracker = tracker
        
        # ç½‘æ ¼çŠ¶æ€ï¼ˆä½¿ç”¨ä¼ å…¥çš„å…±äº«å®ä¾‹ï¼‰
        self.state = grid_state
        
        # è¿è¡Œæ§åˆ¶
        self._running = False
        self._paused = False
        self._resetting = False  # ğŸ”¥ é‡ç½®è¿›è¡Œä¸­æ ‡å¿—ï¼ˆæœ¬é‡‘ä¿æŠ¤ã€å‰¥å¤´çš®é‡ç½®ç­‰ï¼‰
        
        # å¼‚å¸¸è®¡æ•°
        self._error_count = 0
        self._max_errors = 5  # æœ€å¤§é”™è¯¯æ¬¡æ•°ï¼Œè¶…è¿‡åˆ™æš‚åœ
        
        # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨
        self._price_escape_start_time: Optional[float] = None  # ä»·æ ¼è„±ç¦»å¼€å§‹æ—¶é—´
        self._last_escape_check_time: float = 0  # ä¸Šæ¬¡æ£€æŸ¥æ—¶é—´
        self._escape_check_interval: int = 10  # æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
        self._is_resetting: bool = False  # æ˜¯å¦æ­£åœ¨é‡ç½®ç½‘æ ¼
        
        # ğŸ”¥ å‰¥å¤´çš®ç®¡ç†å™¨
        self.scalping_manager: Optional[ScalpingManager] = None
        self._scalping_position_monitor_task: Optional[asyncio.Task] = None
        self._scalping_position_check_interval: int = 3  # å‰¥å¤´çš®æ¨¡å¼æŒä»“æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
        self._last_ws_position_size = Decimal('0')  # ç”¨äºWebSocketäº‹ä»¶é©±åŠ¨
        self._last_ws_position_price = Decimal('0')
        if config.is_scalping_enabled():
            self.scalping_manager = ScalpingManager(config)
            self.logger.info("âœ… å‰¥å¤´çš®ç®¡ç†å™¨å·²å¯ç”¨")
        
        # ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ç®¡ç†å™¨
        self.capital_protection_manager: Optional[CapitalProtectionManager] = None
        if config.is_capital_protection_enabled():
            self.capital_protection_manager = CapitalProtectionManager(config)
            self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤ç®¡ç†å™¨å·²å¯ç”¨")
        
        # ğŸ’° æ­¢ç›ˆç®¡ç†å™¨
        self.take_profit_manager: Optional[TakeProfitManager] = None
        if config.take_profit_enabled:
            self.take_profit_manager = TakeProfitManager(config)
            self.logger.info("âœ… æ­¢ç›ˆç®¡ç†å™¨å·²å¯ç”¨")
        
        # ğŸ”’ ä»·æ ¼é”å®šç®¡ç†å™¨
        self.price_lock_manager: Optional[PriceLockManager] = None
        if config.price_lock_enabled:
            self.price_lock_manager = PriceLockManager(config)
            self.logger.info("âœ… ä»·æ ¼é”å®šç®¡ç†å™¨å·²å¯ç”¨")
        
        # ğŸ’° è´¦æˆ·ä½™é¢è½®è¯¢ï¼ˆBackpackç»Ÿä¸€è´¦æˆ·ï¼‰
        self._balance_monitor_task: Optional[asyncio.Task] = None
        self._balance_update_interval: int = 30  # ä½™é¢æ›´æ–°é—´éš”ï¼ˆç§’ï¼‰
        self._spot_balance: Decimal = Decimal('0')  # ç°è´§ä½™é¢ï¼ˆæœªç”¨ä½œä¿è¯é‡‘ï¼‰
        self._collateral_balance: Decimal = Decimal('0')  # æŠµæŠ¼å“ä½™é¢ï¼ˆç”¨ä½œä¿è¯é‡‘ï¼‰
        self._order_locked_balance: Decimal = Decimal('0')  # è®¢å•å†»ç»“ä½™é¢
        self._last_balance_update: Optional[datetime] = None
        
        self.logger.info(f"ç½‘æ ¼åè°ƒå™¨åˆå§‹åŒ–: {config}")
    
    async def initialize(self):
        """åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ"""
        try:
            self.logger.info("å¼€å§‹åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ...")
            
            # 1. å…ˆåˆå§‹åŒ–æ‰§è¡Œå¼•æ“ï¼ˆè®¾ç½® engine.configï¼‰
            await self.engine.initialize(self.config)
            self.logger.info("æ‰§è¡Œå¼•æ“åˆå§‹åŒ–å®Œæˆ")
            
            # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šè·å–å½“å‰ä»·æ ¼å¹¶è®¾ç½®ä»·æ ¼åŒºé—´
            if self.config.is_follow_mode():
                current_price = await self.engine.get_current_price()
                self.config.update_price_range_for_follow_mode(current_price)
                self.logger.info(
                    f"ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼ ${current_price:,.2f} è®¾ç½®ä»·æ ¼åŒºé—´ "
                    f"[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )
            
            # 2. åˆå§‹åŒ–ç½‘æ ¼çŠ¶æ€
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            self.logger.info(f"ç½‘æ ¼çŠ¶æ€åˆå§‹åŒ–å®Œæˆï¼Œå…±{self.config.grid_count}ä¸ªç½‘æ ¼å±‚çº§")
            
            # 3. åˆå§‹åŒ–ç­–ç•¥ï¼Œç”Ÿæˆæ‰€æœ‰åˆå§‹è®¢å•
            initial_orders = self.strategy.initialize(self.config)
            
            # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šä»·æ ¼åŒºé—´åœ¨åˆå§‹åŒ–åæ‰è®¾ç½®
            if self.config.is_follow_mode():
                self.logger.info(
                    f"ç­–ç•¥åˆå§‹åŒ–å®Œæˆï¼Œç”Ÿæˆ{len(initial_orders)}ä¸ªåˆå§‹è®¢å•ï¼Œ"
                    f"è¦†ç›–ä»·æ ¼åŒºé—´ [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )
            else:
                self.logger.info(
                    f"ç­–ç•¥åˆå§‹åŒ–å®Œæˆï¼Œç”Ÿæˆ{len(initial_orders)}ä¸ªåˆå§‹è®¢å•ï¼Œ"
                    f"è¦†ç›–ä»·æ ¼åŒºé—´ ${self.config.lower_price:,.2f} - ${self.config.upper_price:,.2f}"
                )
            
            # 4. è®¢é˜…è®¢å•æ›´æ–°
            self.engine.subscribe_order_updates(self._on_order_filled)
            self.logger.info("è®¢å•æ›´æ–°è®¢é˜…å®Œæˆ")
            
            # 5. æ‰¹é‡ä¸‹æ‰€æœ‰åˆå§‹è®¢å•ï¼ˆå…³é”®ä¿®æ”¹ï¼‰
            self.logger.info(f"å¼€å§‹æ‰¹é‡æŒ‚å•ï¼Œå…±{len(initial_orders)}ä¸ªè®¢å•...")
            placed_orders = await self.engine.place_batch_orders(initial_orders)
            
            # 6. æ‰¹é‡æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ªï¼ˆåªæ·»åŠ æœªæˆäº¤çš„è®¢å•ï¼‰
            self.logger.info(f"å¼€å§‹æ·»åŠ {len(placed_orders)}ä¸ªè®¢å•åˆ°çŠ¶æ€è¿½è¸ª...")
            added_count = 0
            skipped_count = 0
            for order in placed_orders:
                # ğŸ”¥ æ£€æŸ¥è®¢å•æ˜¯å¦å·²ç»åœ¨çŠ¶æ€ä¸­ï¼ˆå¯èƒ½å·²ç»é€šè¿‡WebSocketæˆäº¤å›è°ƒå¤„ç†ï¼‰
                if order.order_id in self.state.active_orders:
                    skipped_count += 1
                    self.logger.debug(
                        f"â­ï¸ è·³è¿‡å·²å­˜åœ¨è®¢å•: {order.order_id} (Grid {order.grid_id}, {order.side.value})"
                    )
                    continue
                
                # ğŸ”¥ æ£€æŸ¥è®¢å•æ˜¯å¦å·²ç»æˆäº¤ï¼ˆçŠ¶æ€ä¸ºFILLEDï¼‰
                if order.status == GridOrderStatus.FILLED:
                    skipped_count += 1
                    self.logger.debug(
                        f"â­ï¸ è·³è¿‡å·²æˆäº¤è®¢å•: {order.order_id} (Grid {order.grid_id}, {order.side.value})"
                    )
                    continue
                
                self.state.add_order(order)
                added_count += 1
                self.logger.debug(f"âœ… å·²æ·»åŠ è®¢å•åˆ°çŠ¶æ€: {order.order_id} (Grid {order.grid_id}, {order.side.value})")
            
            self.logger.info(
                f"âœ… æˆåŠŸæŒ‚å‡º{len(placed_orders)}/{len(initial_orders)}ä¸ªè®¢å•ï¼Œ"
                f"è¦†ç›–æ•´ä¸ªä»·æ ¼åŒºé—´"
            )
            self.logger.info(
                f"ğŸ“Š è®¢å•æ·»åŠ ç»Ÿè®¡: æ–°å¢={added_count}, è·³è¿‡={skipped_count} "
                f"(å·²å­˜åœ¨æˆ–å·²æˆäº¤)"
            )
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={self.state.pending_buy_orders}, "
                f"å–å•={self.state.pending_sell_orders}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )
            
            # 7. å¯åŠ¨ç³»ç»Ÿ
            self.state.start()
            self._running = True
            
            self.logger.info("âœ… ç½‘æ ¼ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œæ‰€æœ‰è®¢å•å·²å°±ä½ï¼Œç­‰å¾…æˆäº¤")
            
        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}")
            self.state.set_error()
            raise
    
    async def _on_order_filled(self, filled_order: GridOrder):
        """
        è®¢å•æˆäº¤å›è°ƒ - æ ¸å¿ƒé€»è¾‘
        
        å½“è®¢å•æˆäº¤æ—¶ï¼š
        1. è®°å½•æˆäº¤ä¿¡æ¯
        2. æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼
        3. è®¡ç®—åå‘è®¢å•å‚æ•°
        4. ç«‹å³æŒ‚åå‘è®¢å•
        
        Args:
            filled_order: å·²æˆäº¤è®¢å•
        """
        try:
            # ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šé˜²æ­¢åœ¨é‡ç½®æœŸé—´å¤„ç†è®¢å•
            if self._paused:
                self.logger.warning("ç³»ç»Ÿå·²æš‚åœï¼Œè·³è¿‡è®¢å•å¤„ç†")
                return
            
            if self._resetting:
                self.logger.warning("âš ï¸ ç³»ç»Ÿæ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡è®¢å•å¤„ç†")
                return
            
            self.logger.info(
                f"ğŸ“¢ è®¢å•æˆäº¤: {filled_order.side.value} "
                f"{filled_order.filled_amount}@{filled_order.filled_price} "
                f"(Grid {filled_order.grid_id})"
            )
            
            # 1. æ›´æ–°çŠ¶æ€
            self.state.mark_order_filled(
                filled_order.order_id,
                filled_order.filled_price,
                filled_order.filled_amount or filled_order.amount
            )
            
            # 2. è®°å½•åˆ°æŒä»“è·Ÿè¸ªå™¨
            self.tracker.record_filled_order(filled_order)
            
            # ğŸ”¥ 3. æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼
            if self.scalping_manager:
                # æ£€æŸ¥æ˜¯å¦æ˜¯æ­¢ç›ˆè®¢å•æˆäº¤
                if self._is_take_profit_order_filled(filled_order):
                    await self._handle_take_profit_filled()
                    return  # æ­¢ç›ˆæˆäº¤åä¸å†æŒ‚åå‘è®¢å•
                
                # æ›´æ–°æŒä»“ä¿¡æ¯åˆ°å‰¥å¤´çš®ç®¡ç†å™¨
                current_position = self.tracker.get_current_position()
                average_cost = self.tracker.get_average_cost()
                self.scalping_manager.update_position(current_position, average_cost)
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°æ­¢ç›ˆè®¢å•
                await self._update_take_profit_order_if_needed()
            
            # ğŸ›¡ï¸ 3.5. æ£€æŸ¥æœ¬é‡‘ä¿æŠ¤æ¨¡å¼
            if self.capital_protection_manager:
                current_price = filled_order.filled_price
                current_grid_index = self.config.find_nearest_grid_index(current_price)
                await self._check_capital_protection_mode(current_price, current_grid_index)
            
            # 4. è®¡ç®—åå‘è®¢å•å‚æ•°
            # ğŸ”¥ å‰¥å¤´çš®æ¨¡å¼ä¸‹å¯èƒ½ä¸æŒ‚åå‘è®¢å•
            if self.scalping_manager and self.scalping_manager.is_active():
                # å‰¥å¤´çš®æ¨¡å¼ï¼šåªæŒ‚å»ºä»“å•ï¼Œä¸æŒ‚å¹³ä»“å•
                if not self._should_place_reverse_order_in_scalping(filled_order):
                    self.logger.info(f"ğŸ”´ å‰¥å¤´çš®æ¨¡å¼: ä¸æŒ‚åå‘è®¢å•")
                    return
            
            new_side, new_price, new_grid_id = self.strategy.calculate_reverse_order(
                filled_order,
                self.config.grid_interval
            )
            
            # 5. åˆ›å»ºåå‘è®¢å•
            reverse_order = GridOrder(
                order_id="",  # ç­‰å¾…æ‰§è¡Œå¼•æ“å¡«å……
                grid_id=new_grid_id,
                side=new_side,
                price=new_price,
                amount=filled_order.filled_amount or filled_order.amount,  # æ•°é‡å®Œå…¨ä¸€è‡´
                status=GridOrderStatus.PENDING,
                created_at=datetime.now(),
                parent_order_id=filled_order.order_id
            )
            
            # 6. ä¸‹åå‘è®¢å•
            placed_order = await self.engine.place_order(reverse_order)
            self.state.add_order(placed_order)
            
            # 7. è®°å½•å…³è”å…³ç³»
            filled_order.reverse_order_id = placed_order.order_id
            
            self.logger.info(
                f"âœ… åå‘è®¢å•å·²æŒ‚: {new_side.value} "
                f"{reverse_order.amount}@{new_price} "
                f"(Grid {new_grid_id})"
            )
            
            # 8. æ›´æ–°å½“å‰ä»·æ ¼
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(current_price)
            self.state.update_current_price(current_price, current_grid_id)
            
            # ğŸ”¥ 9. æ£€æŸ¥æ˜¯å¦è§¦å‘æˆ–é€€å‡ºå‰¥å¤´çš®æ¨¡å¼
            await self._check_scalping_mode(current_price, current_grid_id)
            
            # é‡ç½®é”™è¯¯è®¡æ•°
            self._error_count = 0
            
        except Exception as e:
            self.logger.error(f"âŒ å¤„ç†è®¢å•æˆäº¤å¤±è´¥: {e}")
            self._handle_error(e)
    
    async def _on_batch_orders_filled(self, filled_orders: List[GridOrder]):
        """
        æ‰¹é‡è®¢å•æˆäº¤å¤„ç†
        
        å¤„ç†ä»·æ ¼å‰§çƒˆæ³¢åŠ¨å¯¼è‡´çš„å¤šè®¢å•åŒæ—¶æˆäº¤
        
        Args:
            filled_orders: å·²æˆäº¤è®¢å•åˆ—è¡¨
        """
        try:
            # ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šé˜²æ­¢åœ¨é‡ç½®æœŸé—´å¤„ç†è®¢å•
            if self._paused:
                self.logger.warning("ç³»ç»Ÿå·²æš‚åœï¼Œè·³è¿‡æ‰¹é‡è®¢å•å¤„ç†")
                return
            
            if self._resetting:
                self.logger.warning("âš ï¸ ç³»ç»Ÿæ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡æ‰¹é‡è®¢å•å¤„ç†")
                return
            
            self.logger.info(
                f"âš¡ æ‰¹é‡æˆäº¤: {len(filled_orders)}ä¸ªè®¢å•"
            )
            
            # 1. æ‰¹é‡æ›´æ–°çŠ¶æ€å’Œè®°å½•
            for order in filled_orders:
                self.state.mark_order_filled(
                    order.order_id,
                    order.filled_price,
                    order.filled_amount or order.amount
                )
                self.tracker.record_filled_order(order)
            
            # 2. æ‰¹é‡è®¡ç®—åå‘è®¢å•
            reverse_params = self.strategy.calculate_batch_reverse_orders(
                filled_orders,
                self.config.grid_interval
            )
            
            # 3. åˆ›å»ºåå‘è®¢å•åˆ—è¡¨
            reverse_orders = []
            for side, price, grid_id, amount in reverse_params:
                order = GridOrder(
                    order_id="",
                    grid_id=grid_id,
                    side=side,
                    price=price,
                    amount=amount,
                    status=GridOrderStatus.PENDING,
                    created_at=datetime.now()
                )
                reverse_orders.append(order)
            
            # 4. æ‰¹é‡ä¸‹å•
            placed_orders = await self.engine.place_batch_orders(reverse_orders)
            
            # 5. æ‰¹é‡æ›´æ–°çŠ¶æ€
            for order in placed_orders:
                self.state.add_order(order)
            
            self.logger.info(
                f"âœ… æ‰¹é‡åå‘è®¢å•å·²æŒ‚: {len(placed_orders)}ä¸ª"
            )
            
            # 6. æ›´æ–°å½“å‰ä»·æ ¼
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(current_price)
            self.state.update_current_price(current_price, current_grid_id)
            
            # é‡ç½®é”™è¯¯è®¡æ•°
            self._error_count = 0
            
        except Exception as e:
            self.logger.error(f"âŒ æ‰¹é‡å¤„ç†è®¢å•æˆäº¤å¤±è´¥: {e}")
            self._handle_error(e)
    
    def _handle_error(self, error: Exception):
        """
        å¤„ç†å¼‚å¸¸
        
        ç­–ç•¥ï¼š
        1. è®°å½•é”™è¯¯
        2. å¢åŠ é”™è¯¯è®¡æ•°
        3. è¶…è¿‡é˜ˆå€¼åˆ™æš‚åœç³»ç»Ÿ
        
        Args:
            error: å¼‚å¸¸å¯¹è±¡
        """
        self._error_count += 1
        
        self.logger.error(
            f"å¼‚å¸¸å‘ç”Ÿ ({self._error_count}/{self._max_errors}): {error}"
        )
        
        # å¦‚æœé”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œæš‚åœç³»ç»Ÿ
        if self._error_count >= self._max_errors:
            self.logger.error(
                f"âŒ é”™è¯¯æ¬¡æ•°è¾¾åˆ°ä¸Šé™({self._max_errors})ï¼Œæš‚åœç³»ç»Ÿ"
            )
            asyncio.create_task(self.pause())
    
    async def start(self):
        """å¯åŠ¨ç½‘æ ¼ç³»ç»Ÿ"""
        if self._running:
            self.logger.warning("ç½‘æ ¼ç³»ç»Ÿå·²ç»åœ¨è¿è¡Œ")
            return
        
        await self.initialize()
        await self.engine.start()
        
        # ğŸ”¥ ä¸»åŠ¨åŒæ­¥åˆå§‹æŒä»“åˆ°WebSocketç¼“å­˜
        # Backpackçš„WebSocketåªåœ¨æŒä»“å˜åŒ–æ—¶æ¨é€ï¼Œä¸ä¼šæ¨é€åˆå§‹çŠ¶æ€
        # æ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨å¯åŠ¨æ—¶ä¸»åŠ¨è·å–ä¸€æ¬¡
        position_data = {'size': Decimal('0'), 'entry_price': Decimal('0'), 'unrealized_pnl': Decimal('0')}
        try:
            self.logger.info("ğŸ“Š æ­£åœ¨åŒæ­¥åˆå§‹æŒä»“æ•°æ®...")
            position_data = await self.engine.get_real_time_position(self.config.symbol)
            
            # å¦‚æœWebSocketç¼“å­˜ä¸ºç©ºï¼Œä½¿ç”¨REST APIè·å–å¹¶åŒæ­¥
            if position_data['size'] == 0 and position_data['entry_price'] == 0:
                positions = await self.engine.exchange.get_positions(symbols=[self.config.symbol])
                if positions and len(positions) > 0:
                    position = positions[0]
                    real_size = position.size or Decimal('0')
                    real_entry_price = position.entry_price or Decimal('0')
                    
                    # åŒæ­¥åˆ°WebSocketç¼“å­˜
                    if hasattr(self.engine.exchange, '_position_cache'):
                        self.engine.exchange._position_cache[self.config.symbol] = {
                            'size': real_size,
                            'entry_price': real_entry_price,
                            'unrealized_pnl': position.unrealized_pnl or Decimal('0'),
                            'side': 'Long' if real_size > 0 else 'Short',
                            'timestamp': datetime.now()
                        }
                        self.logger.info(
                            f"âœ… åˆå§‹æŒä»“å·²åŒæ­¥åˆ°WebSocketç¼“å­˜: "
                            f"{real_size} {self.config.symbol.split('_')[0]}, "
                            f"æˆæœ¬=${real_entry_price:,.2f}"
                        )
                        # æ›´æ–°position_dataä¾›åç»­ä½¿ç”¨
                        position_data = {
                            'size': real_size,
                            'entry_price': real_entry_price,
                            'unrealized_pnl': position.unrealized_pnl or Decimal('0')
                        }
            else:
                # WebSocketç¼“å­˜å·²æœ‰æ•°æ®
                self.logger.info(
                    f"âœ… WebSocketç¼“å­˜å·²æœ‰æŒä»“æ•°æ®: "
                    f"{position_data['size']} {self.config.symbol.split('_')[0]}, "
                    f"æˆæœ¬=${position_data['entry_price']:,.2f}"
                )
        except Exception as e:
            self.logger.warning(f"åŒæ­¥åˆå§‹æŒä»“å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰: {e}")
        
        # ğŸ”¥ æ£€æŸ¥æ˜¯å¦åº”è¯¥ç«‹å³æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼
        # å¦‚æœå¯åŠ¨æ—¶å·²æœ‰æŒä»“ï¼Œä¸”ä»·æ ¼å·²åœ¨è§¦å‘é˜ˆå€¼ä»¥ä¸‹ï¼Œç«‹å³æ¿€æ´»
        if self.config.is_scalping_enabled():
            try:
                current_price = await self.engine.get_current_price()
                current_grid_id = self.config.get_grid_index_by_price(current_price)
                
                # æ›´æ–°scalping_managerçš„æŒä»“ä¿¡æ¯
                if position_data['size'] != 0:
                    self.scalping_manager.update_position(
                        position_data['size'],
                        position_data['entry_price']
                    )
                
                # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å‰¥å¤´çš®æ¨¡å¼ï¼ˆéœ€è¦ä¼ é€’current_priceå’Œcurrent_grid_idï¼‰
                if self.scalping_manager.should_trigger(current_price, current_grid_id):
                    self.logger.info(
                        f"ğŸ¯ æ£€æµ‹åˆ°å¯åŠ¨æ—¶å·²åœ¨è§¦å‘åŒºåŸŸ (Grid {current_grid_id} > "
                        f"Grid {self.config.get_scalping_trigger_grid()})ï¼Œç«‹å³æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼"
                    )
                    await self._activate_scalping_mode(current_price)
                else:
                    self.logger.info(
                        f"ğŸ“Š å‰¥å¤´çš®æ¨¡å¼å¾…è§¦å‘ (å½“å‰: Grid {current_grid_id}, "
                        f"è§¦å‘ç‚¹: Grid {self.config.get_scalping_trigger_grid()})"
                    )
            except Exception as e:
                self.logger.warning(f"æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼å¤±è´¥: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
        
        # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šå¯åŠ¨ä»·æ ¼è„±ç¦»ç›‘æ§
        if self.config.is_follow_mode():
            asyncio.create_task(self._price_escape_monitor())
            self.logger.info("âœ… ä»·æ ¼è„±ç¦»ç›‘æ§å·²å¯åŠ¨")
        
        # ğŸ’° å¯åŠ¨ä½™é¢è½®è¯¢ç›‘æ§
        self._balance_monitor_task = asyncio.create_task(self._balance_monitor_loop())
        self.logger.info("âœ… è´¦æˆ·ä½™é¢è½®è¯¢å·²å¯åŠ¨ï¼ˆé—´éš”30ç§’ï¼‰")
        
        self.logger.info("ğŸš€ ç½‘æ ¼ç³»ç»Ÿå·²å¯åŠ¨")
    
    async def pause(self):
        """æš‚åœç½‘æ ¼ç³»ç»Ÿï¼ˆä¿ç•™æŒ‚å•ï¼‰"""
        self._paused = True
        self.state.pause()
        
        self.logger.info("â¸ï¸ ç½‘æ ¼ç³»ç»Ÿå·²æš‚åœ")
    
    async def resume(self):
        """æ¢å¤ç½‘æ ¼ç³»ç»Ÿ"""
        self._paused = False
        self._error_count = 0  # é‡ç½®é”™è¯¯è®¡æ•°
        self.state.resume()
        
        self.logger.info("â–¶ï¸ ç½‘æ ¼ç³»ç»Ÿå·²æ¢å¤")
    
    async def stop(self):
        """åœæ­¢ç½‘æ ¼ç³»ç»Ÿï¼ˆå–æ¶ˆæ‰€æœ‰æŒ‚å•ï¼‰"""
        self._running = False
        self._paused = False
        
        # ğŸ’° åœæ­¢ä½™é¢ç›‘æ§ä»»åŠ¡
        if self._balance_monitor_task:
            self._balance_monitor_task.cancel()
            try:
                await self._balance_monitor_task
            except asyncio.CancelledError:
                pass
            self.logger.info("âœ… ä½™é¢ç›‘æ§å·²åœæ­¢")
        
        # å–æ¶ˆæ‰€æœ‰æŒ‚å•
        cancelled_count = await self.engine.cancel_all_orders()
        self.logger.info(f"å–æ¶ˆäº†{cancelled_count}ä¸ªæŒ‚å•")
        
        # åœæ­¢å¼•æ“
        await self.engine.stop()
        
        # æ›´æ–°çŠ¶æ€
        self.state.stop()
        
        self.logger.info("â¹ï¸ ç½‘æ ¼ç³»ç»Ÿå·²åœæ­¢")
    
    async def get_statistics(self) -> GridStatistics:
        """
        è·å–ç»Ÿè®¡æ•°æ®ï¼ˆä¼˜å…ˆä½¿ç”¨WebSocketçœŸå®æŒä»“ï¼‰
        
        Returns:
            ç½‘æ ¼ç»Ÿè®¡æ•°æ®
        """
        # æ›´æ–°å½“å‰ä»·æ ¼
        try:
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(current_price)
            self.state.update_current_price(current_price, current_grid_id)
        except Exception as e:
            self.logger.warning(f"è·å–å½“å‰ä»·æ ¼å¤±è´¥: {e}")
        
        # è·å–ç»Ÿè®¡æ•°æ®ï¼ˆæœ¬åœ°è¿½è¸ªå™¨ï¼‰
        stats = self.tracker.get_statistics()
        
        # ğŸ”¥ ä¼˜å…ˆä½¿ç”¨WebSocketç¼“å­˜çš„çœŸå®æŒä»“æ•°æ®
        try:
            position_data = await self.engine.get_real_time_position(self.config.symbol)
            ws_position = position_data['size']
            ws_entry_price = position_data['entry_price']
            
            # å¦‚æœWebSocketæœ‰æ•°æ®ï¼Œè¦†ç›–æœ¬åœ°è¿½è¸ªå™¨çš„æ•°æ®
            if ws_position != 0 or ws_entry_price != 0:
                stats.current_position = ws_position
                stats.average_cost = ws_entry_price
                
                # é‡æ–°è®¡ç®—æœªå®ç°ç›ˆäºï¼ˆä½¿ç”¨WebSocketçš„çœŸå®æŒä»“ï¼‰
                if ws_position != 0 and current_price > 0:
                    stats.unrealized_profit = ws_position * (current_price - ws_entry_price)
        except Exception as e:
            # å¦‚æœè·å–WebSocketæ•°æ®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è¿½è¸ªå™¨çš„æ•°æ®
            self.logger.debug(f"è·å–WebSocketæŒä»“å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è¿½è¸ªå™¨æ•°æ®: {e}")
        
        # ğŸ”¥ æ·»åŠ ç›‘æ§æ–¹å¼ä¿¡æ¯
        stats.monitoring_mode = self.engine.get_monitoring_mode()
        
        # ğŸ’° ä½¿ç”¨çœŸå®çš„è´¦æˆ·ä½™é¢ï¼ˆä» collateral API è½®è¯¢è·å–ï¼‰
        stats.spot_balance = self._spot_balance
        stats.collateral_balance = self._collateral_balance
        stats.order_locked_balance = self._order_locked_balance
        stats.total_balance = self._spot_balance + self._collateral_balance + self._order_locked_balance
        
        # ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤æ¨¡å¼çŠ¶æ€
        if self.capital_protection_manager:
            stats.capital_protection_enabled = True
            stats.capital_protection_active = self.capital_protection_manager.is_active()
            stats.initial_capital = self.capital_protection_manager.get_initial_capital()
            stats.capital_profit_loss = self.capital_protection_manager.get_profit_loss(self._collateral_balance)
        
        # ğŸ”„ ä»·æ ¼è„±ç¦»ç›‘æ§çŠ¶æ€ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰
        if self.config.is_follow_mode() and self._price_escape_start_time is not None:
            import time
            escape_duration = int(time.time() - self._price_escape_start_time)
            stats.price_escape_active = True
            stats.price_escape_duration = escape_duration
            stats.price_escape_timeout = self.config.follow_timeout
            stats.price_escape_remaining = max(0, self.config.follow_timeout - escape_duration)
            
            # åˆ¤æ–­è„±ç¦»æ–¹å‘
            if current_price < self.config.lower_price:
                stats.price_escape_direction = "down"
            elif current_price > self.config.upper_price:
                stats.price_escape_direction = "up"
        
        # ğŸ’° æ­¢ç›ˆæ¨¡å¼çŠ¶æ€
        if self.take_profit_manager:
            stats.take_profit_enabled = True
            stats.take_profit_active = self.take_profit_manager.is_active()
            stats.take_profit_initial_capital = self.take_profit_manager.get_initial_capital()
            stats.take_profit_current_profit = self.take_profit_manager.get_profit_amount(self._collateral_balance)
            stats.take_profit_profit_rate = self.take_profit_manager.get_profit_percentage(self._collateral_balance)
            stats.take_profit_threshold = self.config.take_profit_percentage * 100  # è½¬ä¸ºç™¾åˆ†æ¯”
        
        # ğŸ”’ ä»·æ ¼é”å®šæ¨¡å¼çŠ¶æ€
        if self.price_lock_manager:
            stats.price_lock_enabled = True
            stats.price_lock_active = self.price_lock_manager.is_locked()
            stats.price_lock_threshold = self.config.price_lock_threshold
        
        return stats
    
    def get_state(self) -> GridState:
        """è·å–ç½‘æ ¼çŠ¶æ€"""
        return self.state
    
    def is_running(self) -> bool:
        """æ˜¯å¦è¿è¡Œä¸­"""
        return self._running and not self._paused
    
    def is_paused(self) -> bool:
        """æ˜¯å¦æš‚åœ"""
        return self._paused
    
    def is_stopped(self) -> bool:
        """æ˜¯å¦å·²åœæ­¢"""
        return not self._running
    
    def get_status_text(self) -> str:
        """è·å–çŠ¶æ€æ–‡æœ¬"""
        if self._paused:
            return "â¸ï¸ å·²æš‚åœ"
        elif self._running:
            return "ğŸŸ¢ è¿è¡Œä¸­"
        else:
            return "â¹ï¸ å·²åœæ­¢"
    
    async def _scalping_position_monitor_loop(self):
        """
        [å·²å¼ƒç”¨] å‰¥å¤´çš®æ¨¡å¼æŒä»“ç›‘æ§å¾ªç¯ï¼ˆREST APIè½®è¯¢æ–¹å¼ï¼‰
        
        âš ï¸ æ­¤æ–¹æ³•å·²è¢«WebSocketäº‹ä»¶é©±åŠ¨æ–¹å¼å–ä»£ï¼Œä¿ç•™ä»…ä½œå¤‡ä»½
        ç°åœ¨ä½¿ç”¨ _on_position_update_from_ws() å®æ—¶å¤„ç†æŒä»“æ›´æ–°
        """
        self.logger.warning("âš ï¸ ä½¿ç”¨äº†å·²å¼ƒç”¨çš„REST APIè½®è¯¢ç›‘æ§ï¼ˆåº”è¯¥ä½¿ç”¨WebSocketäº‹ä»¶é©±åŠ¨ï¼‰")
        self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²å¯åŠ¨")
        
        last_position = Decimal('0')
        last_entry_price = Decimal('0')
        
        try:
            while self.scalping_manager and self.scalping_manager.is_active():
                try:
                    # ä»APIè·å–å®æ—¶æŒä»“
                    position_data = await self.engine.get_real_time_position(self.config.symbol)
                    current_position = position_data['size']
                    current_entry_price = position_data['entry_price']
                    
                    # æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                    position_changed = (
                        current_position != last_position or 
                        current_entry_price != last_entry_price
                    )
                    
                    if position_changed:
                        self.logger.info(
                            f"ğŸ“Š æŒä»“å˜åŒ–æ£€æµ‹: "
                            f"æ•°é‡ {last_position} â†’ {current_position}, "
                            f"æˆæœ¬ ${last_entry_price:,.2f} â†’ ${current_entry_price:,.2f}"
                        )
                        
                        # æ›´æ–°å‰¥å¤´çš®ç®¡ç†å™¨çš„æŒä»“ä¿¡æ¯
                        self.scalping_manager.update_position(current_position, current_entry_price)
                        
                        # æ›´æ–°æ­¢ç›ˆè®¢å•
                        await self._update_take_profit_order_after_position_change(
                            current_position, 
                            current_entry_price
                        )
                        
                        # æ›´æ–°è®°å½•
                        last_position = current_position
                        last_entry_price = current_entry_price
                    
                    # ç­‰å¾…ä¸‹æ¬¡æ£€æŸ¥
                    await asyncio.sleep(self._scalping_position_check_interval)
                    
                except asyncio.CancelledError:
                    raise
                except Exception as e:
                    self.logger.error(f"æŒä»“ç›‘æ§å‡ºé”™: {e}")
                    await asyncio.sleep(self._scalping_position_check_interval)
        
        except asyncio.CancelledError:
            self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²å–æ¶ˆ")
        except Exception as e:
            self.logger.error(f"æŒä»“ç›‘æ§å¾ªç¯å¼‚å¸¸: {e}")
        finally:
            self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²ç»“æŸ")
    
    async def _update_take_profit_order_after_position_change(
        self, 
        new_position: Decimal, 
        new_entry_price: Decimal
    ):
        """
        æŒä»“å˜åŒ–åæ›´æ–°æ­¢ç›ˆè®¢å•
        
        Args:
            new_position: æ–°çš„æŒä»“æ•°é‡
            new_entry_price: æ–°çš„å¹³å‡æˆæœ¬ä»·
        """
        if new_position == 0:
            # æŒä»“å½’é›¶ï¼Œå–æ¶ˆæ­¢ç›ˆè®¢å•
            if self.scalping_manager.get_current_take_profit_order():
                tp_order = self.scalping_manager.get_current_take_profit_order()
                try:
                    await self.engine.cancel_order(tp_order.order_id)
                    self.state.remove_order(tp_order.order_id)
                    self.logger.info("âœ… æŒä»“å½’é›¶ï¼Œå·²å–æ¶ˆæ­¢ç›ˆè®¢å•")
                except Exception as e:
                    self.logger.error(f"å–æ¶ˆæ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
            return
        
        # å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•
        old_tp_order = self.scalping_manager.get_current_take_profit_order()
        if old_tp_order:
            try:
                await self.engine.cancel_order(old_tp_order.order_id)
                self.state.remove_order(old_tp_order.order_id)
                self.logger.info(f"ğŸ”„ å·²å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•: {old_tp_order.order_id}")
            except Exception as e:
                self.logger.error(f"å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
        
        # æŒ‚æ–°æ­¢ç›ˆè®¢å•
        await self._place_take_profit_order()
        self.logger.info("âœ… æ­¢ç›ˆè®¢å•å·²æ›´æ–°")
    
    async def _on_position_update_from_ws(self, position_info: Dict[str, Any]) -> None:
        """
        WebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼Œå®æ—¶å“åº”ï¼‰
        
        å½“WebSocketæ”¶åˆ°æŒä»“æ›´æ–°æ¨é€æ—¶è‡ªåŠ¨è°ƒç”¨
        """
        try:
            # åªåœ¨å‰¥å¤´çš®æ¨¡å¼æ¿€æ´»æ—¶å¤„ç†
            if not self.scalping_manager or not self.scalping_manager.is_active():
                return
            
            # åªå¤„ç†å½“å‰äº¤æ˜“å¯¹çš„æŒä»“
            if position_info.get('symbol') != self.config.symbol:
                return
            
            current_position = position_info.get('size', Decimal('0'))
            entry_price = position_info.get('entry_price', Decimal('0'))
            
            # æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
            position_changed = (
                current_position != self._last_ws_position_size or 
                entry_price != self._last_ws_position_price
            )
            
            if position_changed:
                self.logger.info(
                    f"ğŸ“Š WebSocketæŒä»“å˜åŒ–: "
                    f"æ•°é‡ {self._last_ws_position_size} â†’ {current_position}, "
                    f"æˆæœ¬ ${self._last_ws_position_price:,.2f} â†’ ${entry_price:,.2f}"
                )
                
                # æ›´æ–°å‰¥å¤´çš®ç®¡ç†å™¨
                self.scalping_manager.update_position(current_position, entry_price)
                
                # æ›´æ–°æ­¢ç›ˆè®¢å•
                await self._update_take_profit_order_after_position_change(
                    current_position, 
                    entry_price
                )
                
                # æ›´æ–°è®°å½•
                self._last_ws_position_size = current_position
                self._last_ws_position_price = entry_price
                
        except Exception as e:
            self.logger.error(f"å¤„ç†WebSocketæŒä»“æ›´æ–°å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
    
    def __repr__(self) -> str:
        return (
            f"GridCoordinator("
            f"status={self.get_status_text()}, "
            f"position={self.tracker.get_current_position()}, "
            f"errors={self._error_count})"
        )
    
    # ==================== ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨æ–¹æ³• ====================
    
    async def _price_escape_monitor(self):
        """
        ä»·æ ¼è„±ç¦»ç›‘æ§ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰
        
        å®šæœŸæ£€æŸ¥ä»·æ ¼æ˜¯å¦è„±ç¦»ç½‘æ ¼èŒƒå›´ï¼Œå¦‚æœè„±ç¦»æ—¶é—´è¶…è¿‡é˜ˆå€¼åˆ™é‡ç½®ç½‘æ ¼
        """
        import time
        
        self.logger.info("ğŸ” ä»·æ ¼è„±ç¦»ç›‘æ§å¾ªç¯å·²å¯åŠ¨")
        
        while self._running and not self._paused:
            try:
                current_time = time.time()
                
                # æ£€æŸ¥é—´éš”
                if current_time - self._last_escape_check_time < self._escape_check_interval:
                    await asyncio.sleep(1)
                    continue
                
                self._last_escape_check_time = current_time
                
                # è·å–å½“å‰ä»·æ ¼
                current_price = await self.engine.get_current_price()
                
                # æ£€æŸ¥æ˜¯å¦è„±ç¦»
                should_reset, direction = self.config.check_price_escape(current_price)
                
                if should_reset:
                    # è®°å½•è„±ç¦»å¼€å§‹æ—¶é—´
                    if self._price_escape_start_time is None:
                        self._price_escape_start_time = current_time
                        self.logger.warning(
                            f"âš ï¸ ä»·æ ¼è„±ç¦»ç½‘æ ¼èŒƒå›´ï¼ˆ{direction}æ–¹å‘ï¼‰: "
                            f"å½“å‰ä»·æ ¼=${current_price:,.2f}, "
                            f"ç½‘æ ¼åŒºé—´=[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                        )
                    
                    # æ£€æŸ¥è„±ç¦»æ—¶é—´æ˜¯å¦è¶…è¿‡é˜ˆå€¼
                    escape_duration = current_time - self._price_escape_start_time
                    
                    if escape_duration >= self.config.follow_timeout:
                        self.logger.warning(
                            f"ğŸ”„ ä»·æ ¼è„±ç¦»è¶…æ—¶ï¼ˆ{escape_duration:.0f}ç§’ >= {self.config.follow_timeout}ç§’ï¼‰ï¼Œ"
                            f"å‡†å¤‡é‡ç½®ç½‘æ ¼..."
                        )
                        await self._reset_grid_for_price_follow(current_price, direction)
                        self._price_escape_start_time = None
                    else:
                        self.logger.info(
                            f"â³ ä»·æ ¼è„±ç¦»ä¸­ï¼ˆ{direction}æ–¹å‘ï¼‰ï¼Œ"
                            f"å·²æŒç»­ {escape_duration:.0f}/{self.config.follow_timeout}ç§’"
                        )
                else:
                    # ä»·æ ¼å›åˆ°èŒƒå›´å†…ï¼Œé‡ç½®è„±ç¦»è®¡æ—¶
                    if self._price_escape_start_time is not None:
                        self.logger.info(
                            f"âœ… ä»·æ ¼å·²å›åˆ°ç½‘æ ¼èŒƒå›´å†…: ${current_price:,.2f}"
                        )
                        self._price_escape_start_time = None
                    
                    # ğŸ”’ æ£€æŸ¥æ˜¯å¦éœ€è¦è§£é™¤ä»·æ ¼é”å®š
                    if self.price_lock_manager and self.price_lock_manager.is_locked():
                        if self.price_lock_manager.check_unlock_condition(
                            current_price,
                            self.config.lower_price,
                            self.config.upper_price
                        ):
                            self.price_lock_manager.deactivate_lock()
                            self.logger.info("ğŸ”“ ä»·æ ¼é”å®šå·²è§£é™¤ï¼Œæ¢å¤æ­£å¸¸ç½‘æ ¼äº¤æ˜“")
                
                await asyncio.sleep(1)
                
            except asyncio.CancelledError:
                self.logger.info("ä»·æ ¼è„±ç¦»ç›‘æ§å·²åœæ­¢")
                break
            except Exception as e:
                self.logger.error(f"ä»·æ ¼è„±ç¦»ç›‘æ§å‡ºé”™: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
                await asyncio.sleep(10)  # å‡ºé”™åç­‰å¾…10ç§’å†ç»§ç»­
    
    async def _reset_grid_for_price_follow(self, current_price: Decimal, direction: str):
        """
        é‡ç½®ç½‘æ ¼ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰
        
        Args:
            current_price: å½“å‰ä»·æ ¼
            direction: è„±ç¦»æ–¹å‘ ("up" æˆ– "down")
        """
        if self._is_resetting:
            self.logger.warning("ç½‘æ ¼æ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡æœ¬æ¬¡é‡ç½®")
            return
        
        # ğŸ”’ æ£€æŸ¥æ˜¯å¦åº”è¯¥é”å®šè€Œä¸æ˜¯é‡ç½®
        if self.price_lock_manager:
            if self.price_lock_manager.should_lock_instead_of_reset(current_price, direction):
                # æ¿€æ´»ä»·æ ¼é”å®šï¼Œä¸æ‰§è¡Œé‡ç½®
                self.price_lock_manager.activate_lock(current_price)
                self.logger.info(
                    f"ğŸ”’ ä»·æ ¼é”å®šå·²æ¿€æ´»ï¼Œä¸æ‰§è¡Œé‡ç½®ã€‚"
                    f"ä¿ç•™è®¢å•å’ŒæŒä»“ï¼Œç­‰å¾…ä»·æ ¼å›å½’..."
                )
                return
        
        try:
            self._is_resetting = True
            
            self.logger.info(
                f"ğŸ”„ å¼€å§‹é‡ç½®ç½‘æ ¼: å½“å‰ä»·æ ¼=${current_price:,.2f}, è„±ç¦»æ–¹å‘={direction}"
            )
            
            # åˆ¤æ–­æ˜¯å¦éœ€è¦å¹³ä»“ï¼ˆä»·æ ¼æœæœ‰åˆ©æ–¹å‘è„±ç¦» = æ­¢ç›ˆï¼‰
            should_close_position = False
            if self.config.is_long() and direction == "up":
                # åšå¤š + ä»·æ ¼å‘ä¸Š = ç›ˆåˆ©æ–¹å‘ï¼Œéœ€è¦å¹³ä»“æ­¢ç›ˆ
                should_close_position = True
                self.logger.info("ğŸ“Š åšå¤šç½‘æ ¼ä»·æ ¼å‘ä¸Šè„±ç¦» â†’ éœ€è¦å¹³ä»“æ­¢ç›ˆ")
            elif self.config.is_short() and direction == "down":
                # åšç©º + ä»·æ ¼å‘ä¸‹ = ç›ˆåˆ©æ–¹å‘ï¼Œéœ€è¦å¹³ä»“æ­¢ç›ˆ
                should_close_position = True
                self.logger.info("ğŸ“Š åšç©ºç½‘æ ¼ä»·æ ¼å‘ä¸‹è„±ç¦» â†’ éœ€è¦å¹³ä»“æ­¢ç›ˆ")
            else:
                self.logger.info("ğŸ“Š ä»·æ ¼æœä¸åˆ©æ–¹å‘è„±ç¦» â†’ ä¿ç•™æŒä»“")
            
            # 1. å–æ¶ˆæ‰€æœ‰æŒ‚å•
            self.logger.info("ğŸ“‹ æ­¥éª¤ 1/7: å–æ¶ˆæ‰€æœ‰æŒ‚å•...")
            cancelled_count = await self.engine.cancel_all_orders()
            self.logger.info(f"æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")
            
            # 2. éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 2/7: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")
            
            max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
            retry_delay = 2  # æ¯æ¬¡é‡è¯•é—´éš”2ç§’
            
            for retry in range(max_retries):
                # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
                if retry == 0:
                    await asyncio.sleep(1)  # é¦–æ¬¡éªŒè¯ç­‰å¾…1ç§’
                else:
                    await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…2ç§’
                
                # è·å–å½“å‰æœªæˆäº¤è®¢å•æ•°é‡
                open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                open_count = len(open_orders)
                
                if open_count == 0:
                    # éªŒè¯æˆåŠŸ
                    self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                    break
                else:
                    # éªŒè¯å¤±è´¥
                    if retry < max_retries - 1:
                        # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                        self.logger.warning(
                            f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")
                        
                        # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                        retry_cancelled = await self.engine.cancel_all_orders()
                        self.logger.info(f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                    else:
                        # å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒ
                        self.logger.error(
                            f"âŒ è®¢å•å–æ¶ˆéªŒè¯æœ€ç»ˆå¤±è´¥ï¼å·²é‡è¯• {max_retries} æ¬¡ï¼Œä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.error(f"é¢„æœŸ: 0 ä¸ªè®¢å•, å®é™…: {open_count} ä¸ªè®¢å•")
                        self.logger.error("âš ï¸ ç½‘æ ¼é‡ç½®å·²æš‚åœï¼Œä¸ä¼šæŒ‚å‡ºæ–°è®¢å•ï¼Œé¿å…è¶…å‡ºè®¢å•é™åˆ¶")
                        self.logger.error("ğŸ’¡ å»ºè®®: è¯·æ‰‹åŠ¨æ£€æŸ¥äº¤æ˜“æ‰€è®¢å•ï¼Œæˆ–ç­‰å¾…ä¸‹æ¬¡ä»·æ ¼è„±ç¦»æ—¶è‡ªåŠ¨é‡è¯•")
                        
                        # ä¸ç»§ç»­åç»­æ­¥éª¤ï¼Œç›´æ¥è¿”å›
                        return
            
            # 3. å¹³ä»“ï¼ˆå¦‚æœéœ€è¦ï¼‰
            new_capital = None  # ç”¨äºè®°å½•å¹³ä»“åçš„æ–°æœ¬é‡‘
            if should_close_position:
                current_position = self.tracker.get_current_position()
                if current_position != 0:
                    self.logger.info(f"ğŸ“‹ æ­¥éª¤ 3/7: ä»·æ ¼è„±ç¦»å¹³ä»“æ­¢ç›ˆ: {current_position:+.4f}")
                    try:
                        # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                        side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                        await self.engine.place_market_order(
                            side=side,
                            amount=abs(current_position)
                        )
                        self.logger.info("âœ… ä»·æ ¼è„±ç¦»å¹³ä»“å®Œæˆ")
                        
                        # ç­‰å¾…å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
                        await asyncio.sleep(2)
                        
                        # é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆå¹³ä»“åçš„æ–°æœ¬é‡‘ï¼‰
                        try:
                            await self._update_account_balance()
                            new_capital = self._collateral_balance
                            self.logger.info(f"ğŸ“Š ä»·æ ¼è„±ç¦»å¹³ä»“åæ–°æœ¬é‡‘: ${new_capital:,.3f}")
                        except Exception as e:
                            self.logger.error(f"âš ï¸ è·å–å¹³ä»“åä½™é¢å¤±è´¥: {e}")
                    except Exception as e:
                        self.logger.error(f"âŒ ä»·æ ¼è„±ç¦»å¹³ä»“å¤±è´¥: {e}")
                        # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹
                else:
                    self.logger.info("ğŸ“‹ æ­¥éª¤ 3/7: æ— æŒä»“ï¼Œè·³è¿‡å¹³ä»“")
            else:
                self.logger.info("ğŸ“‹ æ­¥éª¤ 3/7: ä¸åˆ©æ–¹å‘è„±ç¦»ï¼Œä¿ç•™æŒä»“")
            
            # 4. æ¸…ç©ºçŠ¶æ€
            self.logger.info("ğŸ“‹ æ­¥éª¤ 4/7: æ¸…ç©ºç½‘æ ¼çŠ¶æ€...")
            self.state.active_orders.clear()
            self.state.pending_buy_orders = 0
            self.state.pending_sell_orders = 0
            self.logger.info("âœ… ç½‘æ ¼çŠ¶æ€å·²æ¸…ç©º")
            
            # 5. æ›´æ–°ä»·æ ¼åŒºé—´
            self.logger.info("ğŸ“‹ æ­¥éª¤ 5/7: æ›´æ–°ä»·æ ¼åŒºé—´...")
            old_range = (self.config.lower_price, self.config.upper_price)
            self.config.update_price_range_for_follow_mode(current_price)
            self.logger.info(
                f"âœ… ä»·æ ¼åŒºé—´å·²æ›´æ–°: "
                f"[${old_range[0]:,.2f}, ${old_range[1]:,.2f}] â†’ "
                f"[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
            )
            
            # 6. é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§
            self.logger.info("ğŸ“‹ æ­¥éª¤ 6/7: é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§...")
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            self.logger.info(f"âœ… ç½‘æ ¼å±‚çº§å·²é‡æ–°åˆå§‹åŒ–ï¼Œå…±{self.config.grid_count}ä¸ª")
            
            # 7. ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•
            self.logger.info("ğŸ“‹ æ­¥éª¤ 7/7: ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•...")
            initial_orders = self.strategy.initialize(self.config)
            placed_orders = await self.engine.place_batch_orders(initial_orders)
            
            # æ·»åŠ åˆ°çŠ¶æ€
            for order in placed_orders:
                if order.order_id in self.state.active_orders:
                    continue
                if order.status == GridOrderStatus.FILLED:
                    continue
                self.state.add_order(order)
            
            # 8. å¦‚æœå¹³ä»“äº†ï¼Œé‡æ–°åˆå§‹åŒ–æœ¬é‡‘
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(new_capital)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")
            
            self.logger.info(
                f"âœ… ç½‘æ ¼é‡ç½®å®Œæˆï¼æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•ï¼Œ"
                f"æ–°ä»·æ ¼åŒºé—´: [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
            )
            
        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            self._handle_error(e)
        finally:
            self._is_resetting = False
    
    # ===========================================
    # ğŸ”¥ å‰¥å¤´çš®æ¨¡å¼ç›¸å…³æ–¹æ³•
    # ===========================================
    
    async def _check_scalping_mode(self, current_price: Decimal, current_grid_index: int):
        """
        æ£€æŸ¥æ˜¯å¦è§¦å‘æˆ–é€€å‡ºå‰¥å¤´çš®æ¨¡å¼
        
        Args:
            current_price: å½“å‰ä»·æ ¼
            current_grid_index: å½“å‰ç½‘æ ¼ç´¢å¼•
        """
        if not self.scalping_manager:
            return
        
        # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å‰¥å¤´çš®
        if self.scalping_manager.should_trigger(current_price, current_grid_index):
            await self._activate_scalping_mode()
        
        # æ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡ºå‰¥å¤´çš®
        elif self.scalping_manager.should_exit(current_price, current_grid_index):
            await self._deactivate_scalping_mode()
    
    async def _check_capital_protection_mode(self, current_price: Decimal, current_grid_index: int):
        """
        æ£€æŸ¥æ˜¯å¦è§¦å‘æœ¬é‡‘ä¿æŠ¤æ¨¡å¼
        
        Args:
            current_price: å½“å‰ä»·æ ¼
            current_grid_index: å½“å‰ç½‘æ ¼ç´¢å¼•
        """
        if not self.capital_protection_manager:
            return
        
        # å¦‚æœå·²ç»è§¦å‘ï¼Œæ£€æŸ¥æ˜¯å¦å›æœ¬
        if self.capital_protection_manager.is_active():
            # æ£€æŸ¥æŠµæŠ¼å“æ˜¯å¦å›æœ¬
            if self.capital_protection_manager.check_capital_recovery(self._collateral_balance):
                self.logger.warning(
                    f"ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ï¼šæŠµæŠ¼å“å·²å›æœ¬ï¼Œå‡†å¤‡é‡ç½®ç½‘æ ¼ï¼"
                )
                await self._execute_capital_protection_reset()
        else:
            # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘
            if self.capital_protection_manager.should_trigger(current_price, current_grid_index):
                self.capital_protection_manager.activate()
                self.logger.warning(
                    f"ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤å·²æ¿€æ´»ï¼ç­‰å¾…æŠµæŠ¼å“å›æœ¬... "
                    f"åˆå§‹æœ¬é‡‘: ${self.capital_protection_manager.get_initial_capital():,.2f}"
                )
    
    async def _execute_capital_protection_reset(self):
        """æ‰§è¡Œæœ¬é‡‘ä¿æŠ¤é‡ç½®ï¼ˆå¹³ä»“åé‡ç½®å¹¶é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ›¡ï¸ å¼€å§‹æ‰§è¡Œæœ¬é‡‘ä¿æŠ¤é‡ç½®ï¼ˆé”å®šç³»ç»Ÿï¼‰...")
            
            # 1. å–æ¶ˆæ‰€æœ‰è®¢å•
            self.logger.info("ğŸ“‹ å–æ¶ˆæ‰€æœ‰è®¢å•...")
            await self.engine.cancel_all_orders()
            
            # 2. å¹³æ‰æ‰€æœ‰æŒä»“
            current_position = self.tracker.get_current_position()
            if current_position != 0:
                self.logger.info(f"ğŸ“Š æœ¬é‡‘ä¿æŠ¤å¹³ä»“: {current_position:+.4f}")
                try:
                    # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                    side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                    await self.engine.place_market_order(
                        side=side,
                        amount=abs(current_position)
                    )
                    self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤å¹³ä»“å®Œæˆ")
                except Exception as e:
                    self.logger.error(f"âŒ æœ¬é‡‘ä¿æŠ¤å¹³ä»“å¤±è´¥: {e}")
                    # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹
            
            # 3. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)
            
            # 4. é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆå¹³ä»“åçš„æ–°æœ¬é‡‘ï¼‰
            try:
                await self._update_account_balance()
                new_capital = self._collateral_balance
                self.logger.info(f"ğŸ“Š æœ¬é‡‘ä¿æŠ¤åæ–°æœ¬é‡‘: ${new_capital:,.3f}")
            except Exception as e:
                self.logger.error(f"âš ï¸ è·å–å¹³ä»“åä½™é¢å¤±è´¥: {e}")
                new_capital = self._collateral_balance  # ä½¿ç”¨å½“å‰å€¼
            
            # 5. æ ¹æ®ç½‘æ ¼ç±»å‹å†³å®šåç»­æ“ä½œ
            if self.config.is_follow_mode():
                # ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡æ–°å¯åŠ¨ï¼ˆé‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰
                self.logger.info("ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®ç½‘æ ¼å¹¶é‡æ–°å¯åŠ¨...")
                await self._reset_and_restart(new_capital=new_capital)
                self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤é‡ç½®å®Œæˆï¼Œç½‘æ ¼å·²é‡æ–°å¯åŠ¨")
            else:
                # å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šåœæ­¢è¿è¡Œ
                self.logger.info("â¹ï¸ å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šåœæ­¢è¿è¡Œ...")
                await self.stop()
                self.logger.warning("ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ï¼šå›ºå®šèŒƒå›´ç½‘æ ¼å·²åœæ­¢ï¼Œè¯·æ‰‹åŠ¨é‡æ–°å¯åŠ¨")
            
        except Exception as e:
            self.logger.error(f"âŒ æœ¬é‡‘ä¿æŠ¤é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")
    
    async def _execute_take_profit_reset(self):
        """æ‰§è¡Œæ­¢ç›ˆé‡ç½®ï¼ˆæ— è®ºå“ªç§ç½‘æ ¼éƒ½é‡ç½®å¹¶é‡å¯ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ’° å¼€å§‹æ‰§è¡Œæ­¢ç›ˆé‡ç½®ï¼ˆé”å®šç³»ç»Ÿï¼‰...")
            
            # 1. å–æ¶ˆæ‰€æœ‰è®¢å•
            self.logger.info("ğŸ“‹ å–æ¶ˆæ‰€æœ‰è®¢å•...")
            await self.engine.cancel_all_orders()
            
            # 2. å¹³æ‰æ‰€æœ‰æŒä»“
            current_position = self.tracker.get_current_position()
            if current_position != 0:
                self.logger.info(f"ğŸ“Š æ­¢ç›ˆå¹³ä»“: {current_position:+.4f}")
                try:
                    # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                    side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                    await self.engine.place_market_order(
                        side=side,
                        amount=abs(current_position)
                    )
                    self.logger.info("âœ… æ­¢ç›ˆå¹³ä»“å®Œæˆ")
                except Exception as e:
                    self.logger.error(f"âŒ æ­¢ç›ˆå¹³ä»“å¤±è´¥: {e}")
                    # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹
            
            # 3. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)
            
            # 4. é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆæ­¢ç›ˆåçš„æ–°æœ¬é‡‘ï¼‰
            try:
                await self._update_account_balance()
                new_capital = self._collateral_balance
                self.logger.info(f"ğŸ“Š æ­¢ç›ˆåæ–°æœ¬é‡‘: ${new_capital:,.3f}")
            except Exception as e:
                self.logger.error(f"âš ï¸ è·å–æ­¢ç›ˆåä½™é¢å¤±è´¥: {e}")
                new_capital = self._collateral_balance  # ä½¿ç”¨å½“å‰å€¼
            
            # 5. é‡ç½®ç½‘æ ¼ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼å’Œå›ºå®šèŒƒå›´ç½‘æ ¼éƒ½é‡ç½®ï¼‰
            if self.config.is_follow_mode():
                # ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼é‡æ–°æŒ‚å•
                self.logger.info("ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡æ–°å¯åŠ¨...")
                await self._reset_and_restart(new_capital=new_capital)
                self.logger.info("âœ… æ­¢ç›ˆé‡ç½®å®Œæˆï¼Œä»·æ ¼ç§»åŠ¨ç½‘æ ¼å·²é‡å¯")
            else:
                # å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šä¿æŒåŸæœ‰èŒƒå›´é‡æ–°æŒ‚å•
                self.logger.info("ğŸ”„ å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šä¿æŒèŒƒå›´é‡æ–°æŒ‚å•...")
                await self._reset_fixed_range_grid(new_capital=new_capital)
                self.logger.info("âœ… æ­¢ç›ˆé‡ç½®å®Œæˆï¼Œå›ºå®šèŒƒå›´ç½‘æ ¼å·²é‡å¯")
            
        except Exception as e:
            self.logger.error(f"âŒ æ­¢ç›ˆé‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")
    
    async def _reset_and_restart(self, new_capital: Optional[Decimal] = None):
        """é‡ç½®å¹¶é‡æ–°å¯åŠ¨ç½‘æ ¼
        
        Args:
            new_capital: æ–°çš„åˆå§‹æœ¬é‡‘ï¼ˆæ­¢ç›ˆåä½¿ç”¨ï¼‰
        """
        try:
            self.logger.info("ğŸ”„ é‡ç½®ç½‘æ ¼çŠ¶æ€...")
            
            # 1. é‡ç½®æ‰€æœ‰ç®¡ç†å™¨çŠ¶æ€
            if self.scalping_manager:
                self.scalping_manager.reset()
            if self.capital_protection_manager:
                self.capital_protection_manager.reset()
            if self.take_profit_manager:
                self.take_profit_manager.reset()
            if self.price_lock_manager:
                self.price_lock_manager.reset()
            
            # 2. é‡ç½®è¿½è¸ªå™¨å’ŒçŠ¶æ€
            self.tracker.reset()
            self.state.clear_all_orders()
            
            # 3. ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ›´æ–°ä»·æ ¼åŒºé—´
            if self.config.is_follow_mode():
                current_price = await self.engine.get_current_price()
                self.config.update_price_range_for_follow_mode(current_price)
                self.logger.info(
                    f"ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼ ${current_price:,.2f} "
                    f"é‡æ–°è®¾ç½®ä»·æ ¼åŒºé—´ [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )
            
            # 4. é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            
            # 5. ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•
            self.logger.info("ğŸš€ é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å¹¶æŒ‚å•...")
            initial_orders = self.strategy.initialize(self.config)
            self.logger.info(f"ğŸ“‹ ç”Ÿæˆ {len(initial_orders)} ä¸ªåˆå§‹è®¢å•")
            
            placed_orders = await self.engine.place_batch_orders(initial_orders)
            self.logger.info(f"âœ… æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")
            
            # 6. æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ª
            for order in placed_orders:
                if order.order_id in self.state.active_orders:
                    continue
                if order.status == GridOrderStatus.FILLED:
                    self.logger.debug(f"è®¢å• {order.order_id} ç«‹å³æˆäº¤ï¼Œè·³è¿‡æ·»åŠ ")
                    continue
                self.state.add_order(order)
            
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={len([o for o in self.state.active_orders.values() if o.side == GridOrderSide.BUY})}, "
                f"å–å•={len([o for o in self.state.active_orders.values() if o.side == GridOrderSide.SELL])}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )
            
            # 7. é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼ˆæ­¢ç›ˆåï¼‰
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(new_capital)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")
            
            self.logger.info("âœ… ç½‘æ ¼é‡ç½®å®Œæˆï¼Œç»§ç»­è¿è¡Œ")
            
        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(f"è¯¦ç»†é”™è¯¯: {traceback.format_exc()}")
            raise
    
    async def _reset_fixed_range_grid(self, new_capital: Optional[Decimal] = None):
        """é‡ç½®å›ºå®šèŒƒå›´ç½‘æ ¼ï¼ˆä¿æŒåŸæœ‰èŒƒå›´ï¼‰
        
        Args:
            new_capital: æ–°çš„åˆå§‹æœ¬é‡‘ï¼ˆæ­¢ç›ˆåä½¿ç”¨ï¼‰
        """
        try:
            self.logger.info("ğŸ”„ é‡ç½®å›ºå®šèŒƒå›´ç½‘æ ¼ï¼ˆä¿æŒä»·æ ¼åŒºé—´ï¼‰...")
            
            # é‡ç½®æ‰€æœ‰ç®¡ç†å™¨çŠ¶æ€
            if self.scalping_manager:
                self.scalping_manager.reset()
            if self.capital_protection_manager:
                self.capital_protection_manager.reset()
            if self.take_profit_manager:
                self.take_profit_manager.reset()
            
            # é‡ç½®è¿½è¸ªå™¨å’ŒçŠ¶æ€
            self.tracker.reset()
            self.state.clear_all_orders()
            
            # é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§ï¼ˆä¿æŒåŸæœ‰ä»·æ ¼åŒºé—´ï¼‰
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            
            # ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•ï¼ˆä½¿ç”¨åŸæœ‰ä»·æ ¼èŒƒå›´ï¼‰
            self.logger.info(
                f"ğŸš€ é‡æ–°åˆå§‹åŒ–å›ºå®šèŒƒå›´ç½‘æ ¼å¹¶æŒ‚å•: "
                f"${self.config.lower_price:,.2f} - ${self.config.upper_price:,.2f}"
            )
            initial_orders = self.strategy.initialize(self.config)
            self.logger.info(f"ğŸ“‹ ç”Ÿæˆ {len(initial_orders)} ä¸ªåˆå§‹è®¢å•")
            
            placed_orders = await self.engine.place_batch_orders(initial_orders)
            self.logger.info(f"âœ… æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")
            
            # æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ª
            for order in placed_orders:
                if order.order_id in self.state.active_orders:
                    continue
                if order.status == GridOrderStatus.FILLED:
                    self.logger.debug(f"è®¢å• {order.order_id} ç«‹å³æˆäº¤ï¼Œè·³è¿‡æ·»åŠ ")
                    continue
                self.state.add_order(order)
            
            buy_count = len([o for o in self.state.active_orders.values() if o.side == GridOrderSide.BUY])
            sell_count = len([o for o in self.state.active_orders.values() if o.side == GridOrderSide.SELL])
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={buy_count}, "
                f"å–å•={sell_count}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )
            
            # ğŸ”¥ é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼ˆæ­¢ç›ˆåï¼‰
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(new_capital)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")
            
            self.logger.info("âœ… å›ºå®šèŒƒå›´ç½‘æ ¼é‡ç½®å®Œæˆï¼Œç»§ç»­è¿è¡Œ")
            
        except Exception as e:
            self.logger.error(f"âŒ å›ºå®šèŒƒå›´ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            raise
    
    async def _activate_scalping_mode(self):
        """æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼"""
        self.logger.warning("ğŸ”´ æ­£åœ¨æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼...")
        
        # 1. æ¿€æ´»å‰¥å¤´çš®ç®¡ç†å™¨
        self.scalping_manager.activate()
        
        # 2. å–æ¶ˆæ‰€æœ‰åå‘è®¢å•ï¼ˆåšå¤šå–æ¶ˆå–å•ï¼Œåšç©ºå–æ¶ˆä¹°å•ï¼‰
        orders_to_cancel = self.scalping_manager.get_orders_to_cancel_on_trigger()
        self.logger.info(f"ğŸ“‹ å–æ¶ˆæ‰€æœ‰{orders_to_cancel}è®¢å•...")
        
        cancelled_count = 0
        for order_id, order in list(self.state.active_orders.items()):
            should_cancel = (
                (orders_to_cancel == "sell" and order.side == GridOrderSide.SELL) or
                (orders_to_cancel == "buy" and order.side == GridOrderSide.BUY)
            )
            
            if should_cancel:
                try:
                    await self.engine.cancel_order(order.order_id)
                    self.state.remove_order(order.order_id)
                    cancelled_count += 1
                except Exception as e:
                    self.logger.error(f"å–æ¶ˆè®¢å•å¤±è´¥ {order.order_id}: {e}")
        
        self.logger.info(f"âœ… å·²å–æ¶ˆ {cancelled_count} ä¸ª{orders_to_cancel}è®¢å•")
        
        # 3. ğŸ”¥ æ··åˆç­–ç•¥è·å–å®æ—¶æŒä»“ï¼šWebSocketä¼˜å…ˆï¼ŒREST APIå¤‡ç”¨
        self.logger.info("ğŸ“Š æ­£åœ¨è·å–å®æ—¶æŒä»“ä¿¡æ¯ï¼ˆWebSocketä¼˜å…ˆï¼ŒREST APIå¤‡ç”¨ï¼‰...")
        
        # ç¬¬ä¸€æ­¥ï¼šå°è¯•ä»WebSocketç¼“å­˜è·å–
        position_data = await self.engine.get_real_time_position(self.config.symbol)
        current_position = position_data['size']
        average_cost = position_data['entry_price']
        data_source = "WebSocket"
        
        # ç¬¬äºŒæ­¥ï¼šå¦‚æœWebSocketç¼“å­˜ä¸ºç©ºï¼Œä½¿ç”¨REST APIä½œä¸ºå¤‡ç”¨
        if current_position == 0 and average_cost == 0:
            self.logger.warning(
                "âš ï¸ WebSocketæŒä»“ç¼“å­˜ä¸ºç©ºï¼ˆäº¤æ˜“æ‰€æœªæ¨é€åˆå§‹æŒä»“ï¼‰ï¼Œ"
                "ä½¿ç”¨REST APIè·å–å‡†ç¡®æ•°æ®..."
            )
            
            try:
                # è°ƒç”¨REST APIè·å–æŒä»“ï¼ˆå‡†ç¡®ä½†æœ‰å»¶è¿Ÿï¼‰
                positions = await self.engine.exchange.get_positions(
                    symbols=[self.config.symbol]
                )
                
                if positions and len(positions) > 0:
                    position = positions[0]
                    current_position = position.size or Decimal('0')
                    average_cost = position.entry_price or Decimal('0')
                    
                    # æ ¹æ®æ–¹å‘ç¡®å®šæŒä»“ç¬¦å·
                    if hasattr(position, 'side'):
                        from ....adapters.exchanges import PositionSide
                        if position.side == PositionSide.SHORT and current_position != 0:
                            current_position = -current_position
                    
                    data_source = "REST API"
                    
                    # åŒæ­¥åˆ°WebSocketç¼“å­˜ï¼ˆä¾›åç»­ä½¿ç”¨ï¼‰
                    if not hasattr(self.engine.exchange, '_position_cache'):
                        self.engine.exchange._position_cache = {}
                    self.engine.exchange._position_cache[self.config.symbol] = {
                        'size': current_position,
                        'entry_price': average_cost,
                        'unrealized_pnl': position.unrealized_pnl or Decimal('0'),
                        'side': 'Long' if current_position > 0 else 'Short',
                        'timestamp': datetime.now()
                    }
                    
                    self.logger.info(
                        f"âœ… REST APIè·å–æˆåŠŸ: {current_position} {self.config.symbol.split('_')[0]}, "
                        f"æˆæœ¬=${average_cost:,.2f}ï¼Œå·²åŒæ­¥åˆ°WebSocketç¼“å­˜"
                    )
                else:
                    self.logger.warning("âš ï¸ REST APIè¿”å›ç©ºæŒä»“")
                    
            except Exception as e:
                self.logger.error(f"âŒ REST APIè·å–æŒä»“å¤±è´¥: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
        
        self.logger.info(
            f"ğŸ“Š æœ€ç»ˆæŒä»“ï¼ˆæ¥æº: {data_source}ï¼‰: "
            f"{current_position} {self.config.symbol.split('_')[0]}, "
            f"å¹³å‡æˆæœ¬: ${average_cost:,.2f}"
        )
        
        self.scalping_manager.update_position(current_position, average_cost)
        self._last_ws_position_size = current_position
        self._last_ws_position_price = average_cost
        
        # 4. æŒ‚æ­¢ç›ˆè®¢å•ï¼ˆå¦‚æœæœ‰æŒä»“ï¼‰
        await self._place_take_profit_order()
        
        # 5. ğŸ”¥ æ³¨å†ŒWebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼Œä¸å†è½®è¯¢ï¼‰
        if not hasattr(self.engine.exchange, '_position_callbacks'):
            self.engine.exchange._position_callbacks = []
        if self._on_position_update_from_ws not in self.engine.exchange._position_callbacks:
            self.engine.exchange._position_callbacks.append(self._on_position_update_from_ws)
            self.logger.info("âœ… å·²æ³¨å†ŒWebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰")
        
        self.logger.warning("âœ… å‰¥å¤´çš®æ¨¡å¼å·²æ¿€æ´»")
    
    async def _deactivate_scalping_mode(self):
        """é€€å‡ºå‰¥å¤´çš®æ¨¡å¼ï¼Œæ¢å¤æ­£å¸¸ç½‘æ ¼"""
        self.logger.info("ğŸŸ¢ æ­£åœ¨é€€å‡ºå‰¥å¤´çš®æ¨¡å¼...")
        
        # 1. ğŸ”¥ ç§»é™¤WebSocketæŒä»“æ›´æ–°å›è°ƒ
        if hasattr(self.engine.exchange, '_position_callbacks'):
            if self._on_position_update_from_ws in self.engine.exchange._position_callbacks:
                self.engine.exchange._position_callbacks.remove(self._on_position_update_from_ws)
                self.logger.info("âœ… å·²ç§»é™¤WebSocketæŒä»“æ›´æ–°å›è°ƒ")
        
        # 2. å–æ¶ˆæ­¢ç›ˆè®¢å•
        if self.scalping_manager.get_current_take_profit_order():
            tp_order = self.scalping_manager.get_current_take_profit_order()
            try:
                await self.engine.cancel_order(tp_order.order_id)
                self.state.remove_order(tp_order.order_id)
                self.logger.info(f"âœ… å·²å–æ¶ˆæ­¢ç›ˆè®¢å•: {tp_order.order_id}")
            except Exception as e:
                self.logger.error(f"å–æ¶ˆæ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
        
        # 3. åœç”¨å‰¥å¤´çš®ç®¡ç†å™¨
        self.scalping_manager.deactivate()
        
        # 3. æ¢å¤æ­£å¸¸ç½‘æ ¼ï¼ˆé‡æ–°æŒ‚æ‰€æœ‰è®¢å•ï¼‰
        self.logger.info("ğŸ”„ æ¢å¤æ­£å¸¸ç½‘æ ¼æ¨¡å¼ï¼Œé‡æ–°æŒ‚å•...")
        
        # é‡æ–°ç”Ÿæˆæ‰€æœ‰ç½‘æ ¼è®¢å•
        initial_orders = self.strategy.initialize(self.config)
        
        # æ‰¹é‡æŒ‚å•
        placed_orders = await self.engine.place_batch_orders(initial_orders)
        
        # æ›´æ–°çŠ¶æ€
        for order in placed_orders:
            if order.order_id not in self.state.active_orders:
                self.state.add_order(order)
        
        self.logger.info(f"âœ… å·²æ¢å¤æ­£å¸¸ç½‘æ ¼ï¼ŒæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")
    
    async def _place_take_profit_order(self):
        """æŒ‚æ­¢ç›ˆè®¢å•"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return
        
        # è®¡ç®—æ­¢ç›ˆè®¢å•
        tp_order = self.scalping_manager.calculate_take_profit_order()
        
        if not tp_order:
            self.logger.info("ğŸ“‹ å½“å‰æ— æŒä»“ï¼Œä¸æŒ‚æ­¢ç›ˆè®¢å•")
            return
        
        try:
            # ä¸‹æ­¢ç›ˆè®¢å•
            placed_order = await self.engine.place_order(tp_order)
            self.state.add_order(placed_order)
            
            self.logger.info(
                f"ğŸ’° æ­¢ç›ˆè®¢å•å·²æŒ‚: {placed_order.side.value} "
                f"{placed_order.amount}@{placed_order.price} "
                f"(Grid {placed_order.grid_id})"
            )
        except Exception as e:
            self.logger.error(f"âŒ æŒ‚æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
    
    async def _update_take_profit_order_if_needed(self):
        """å¦‚æœæŒä»“å˜åŒ–ï¼Œæ›´æ–°æ­¢ç›ˆè®¢å•"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return
        
        current_position = self.tracker.get_current_position()
        
        # æ£€æŸ¥æ­¢ç›ˆè®¢å•æ˜¯å¦éœ€è¦æ›´æ–°
        if not self.scalping_manager.is_take_profit_order_outdated(current_position):
            return
        
        self.logger.info("ğŸ“‹ æŒä»“å˜åŒ–ï¼Œæ›´æ–°æ­¢ç›ˆè®¢å•...")
        
        # å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•
        old_tp_order = self.scalping_manager.get_current_take_profit_order()
        if old_tp_order:
            try:
                await self.engine.cancel_order(old_tp_order.order_id)
                self.state.remove_order(old_tp_order.order_id)
                self.logger.info(f"âœ… å·²å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•: {old_tp_order.order_id}")
            except Exception as e:
                self.logger.error(f"å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
        
        # æŒ‚æ–°æ­¢ç›ˆè®¢å•
        await self._place_take_profit_order()
    
    def _is_take_profit_order_filled(self, filled_order: GridOrder) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ˜¯æ­¢ç›ˆè®¢å•æˆäº¤"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return False
        
        tp_order = self.scalping_manager.get_current_take_profit_order()
        if not tp_order:
            return False
        
        return filled_order.order_id == tp_order.order_id
    
    async def _handle_take_profit_filled(self):
        """å¤„ç†å‰¥å¤´çš®æ­¢ç›ˆè®¢å•æˆäº¤ï¼ˆæŒä»“å·²å¹³ä»“ï¼Œéœ€è¦é‡ç½®ç½‘æ ¼å¹¶é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ¯ å‰¥å¤´çš®æ­¢ç›ˆè®¢å•å·²æˆäº¤ï¼ï¼ˆé”å®šç³»ç»Ÿï¼‰")
            
            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)
            
            # é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆæ­¢ç›ˆåçš„æ–°æœ¬é‡‘ï¼‰
            try:
                await self._update_account_balance()
                new_capital = self._collateral_balance
                self.logger.info(f"ğŸ“Š å‰¥å¤´çš®æ­¢ç›ˆåæ–°æœ¬é‡‘: ${new_capital:,.3f}")
            except Exception as e:
                self.logger.error(f"âš ï¸ è·å–æ­¢ç›ˆåä½™é¢å¤±è´¥: {e}")
                new_capital = self._collateral_balance  # ä½¿ç”¨å½“å‰å€¼
            
            # æ ¹æ®ç½‘æ ¼ç±»å‹å†³å®šåç»­è¡Œä¸º
            if self.config.is_follow_mode():
                # è·Ÿéšç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡å¯ï¼ˆé‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰
                self.logger.info("ğŸ”„ è·Ÿéšç§»åŠ¨ç½‘æ ¼æ¨¡å¼ï¼šå‡†å¤‡é‡ç½®å¹¶é‡å¯...")
                await self._reset_and_restart(new_capital=new_capital)
                self.logger.info("âœ… å‰¥å¤´çš®é‡ç½®å®Œæˆï¼Œä»·æ ¼ç§»åŠ¨ç½‘æ ¼å·²é‡å¯")
            else:
                # æ™®é€š/é©¬ä¸ç½‘æ ¼ï¼šåœæ­¢ç³»ç»Ÿ
                self.logger.info("â¸ï¸  æ™®é€š/é©¬ä¸ç½‘æ ¼æ¨¡å¼ï¼šåœæ­¢ç³»ç»Ÿ")
                await self.stop()
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")
    
    def _should_place_reverse_order_in_scalping(self, filled_order: GridOrder) -> bool:
        """
        åˆ¤æ–­åœ¨å‰¥å¤´çš®æ¨¡å¼ä¸‹æ˜¯å¦åº”è¯¥æŒ‚åå‘è®¢å•
        
        Args:
            filled_order: å·²æˆäº¤è®¢å•
        
        Returns:
            æ˜¯å¦åº”è¯¥æŒ‚åå‘è®¢å•
        """
        from ..models import GridType
        
        # åšå¤šç½‘æ ¼ï¼šåªæŒ‚ä¹°å•ï¼ˆå»ºä»“ï¼‰ï¼Œä¸æŒ‚å–å•ï¼ˆå¹³ä»“ï¼‰
        if self.config.grid_type in [GridType.LONG, GridType.FOLLOW_LONG, GridType.MARTINGALE_LONG]:
            # å¦‚æœæˆäº¤çš„æ˜¯ä¹°å•ï¼Œåº”è¯¥æŒ‚å–å•ï¼Œä½†å‰¥å¤´çš®æ¨¡å¼ä¸æŒ‚
            return filled_order.side == GridOrderSide.SELL
        
        # åšç©ºç½‘æ ¼ï¼šåªæŒ‚å–å•ï¼ˆå»ºä»“ï¼‰ï¼Œä¸æŒ‚ä¹°å•ï¼ˆå¹³ä»“ï¼‰
        else:
            # å¦‚æœæˆäº¤çš„æ˜¯å–å•ï¼Œåº”è¯¥æŒ‚ä¹°å•ï¼Œä½†å‰¥å¤´çš®æ¨¡å¼ä¸æŒ‚
            return filled_order.side == GridOrderSide.BUY
    
    async def _balance_monitor_loop(self):
        """
        è´¦æˆ·ä½™é¢ç›‘æ§å¾ªç¯
        
        å®šæœŸè°ƒç”¨REST APIæŸ¥è¯¢è´¦æˆ·ä½™é¢ï¼ˆUSDCï¼‰
        """
        self.logger.info("ğŸ’° è´¦æˆ·ä½™é¢ç›‘æ§å¾ªç¯å·²å¯åŠ¨")
        
        while self._running:
            try:
                await self._update_account_balance()
                await asyncio.sleep(self._balance_update_interval)
            except asyncio.CancelledError:
                self.logger.info("ğŸ’° ä½™é¢ç›‘æ§å¾ªç¯è¢«å–æ¶ˆ")
                break
            except Exception as e:
                self.logger.error(f"âŒ ä½™é¢æ›´æ–°å¤±è´¥: {e}")
                await asyncio.sleep(self._balance_update_interval)
    
    async def _update_account_balance(self):
        """
        æ›´æ–°è´¦æˆ·ä½™é¢
        
        ä» Backpack collateral API è·å–USDCä½™é¢
        - spot_balance: availableQuantityï¼ˆç°è´§ä½™é¢ï¼Œæœªç”¨ä½œä¿è¯é‡‘ï¼‰
        - collateral_balance: lendQuantityï¼ˆæŠµæŠ¼å“ä½™é¢ï¼Œç”¨ä½œä¿è¯é‡‘ï¼‰
        - order_locked_balance: openOrderQuantityï¼ˆè®¢å•å†»ç»“ä½™é¢ï¼‰
        """
        try:
            # è°ƒç”¨äº¤æ˜“æ‰€APIè·å–æ‰€æœ‰ä½™é¢
            balances = await self.engine.exchange.get_balances()
            
            # æŸ¥æ‰¾USDCä½™é¢
            usdc_balance = None
            for balance in balances:
                if balance.currency.upper() == 'USDC':
                    usdc_balance = balance
                    break
            
            if usdc_balance:
                # ğŸ”¥ ä» raw_data ä¸­æå–è¯¦ç»†çš„ä½™é¢ä¿¡æ¯
                raw_data = usdc_balance.raw_data
                
                # availableQuantity = ç°è´§ä½™é¢ï¼ˆæœªç”¨ä½œä¿è¯é‡‘çš„ï¼‰
                self._spot_balance = self._safe_decimal(raw_data.get('availableQuantity', '0'))
                
                # lendQuantity = æŠµæŠ¼å“ä½™é¢ï¼ˆç”¨ä½œä¿è¯é‡‘çš„ï¼‰
                self._collateral_balance = self._safe_decimal(raw_data.get('lendQuantity', '0'))
                
                # openOrderQuantity = è®¢å•å†»ç»“ä½™é¢
                self._order_locked_balance = self._safe_decimal(raw_data.get('openOrderQuantity', '0'))
                
                self._last_balance_update = datetime.now()
                
                # ğŸ›¡ï¸ å¦‚æœå¯ç”¨äº†æœ¬é‡‘ä¿æŠ¤ï¼Œè®°å½•åˆå§‹æœ¬é‡‘ï¼ˆé¦–æ¬¡è·å–ï¼‰
                if self.capital_protection_manager:
                    if self.capital_protection_manager.get_initial_capital() == Decimal('0'):
                        self.capital_protection_manager.initialize_capital(self._collateral_balance)
                
                # ğŸ’° å¦‚æœå¯ç”¨äº†æ­¢ç›ˆæ¨¡å¼ï¼Œè®°å½•/æ›´æ–°åˆå§‹æœ¬é‡‘
                if self.take_profit_manager:
                    if self.take_profit_manager.get_initial_capital() == Decimal('0'):
                        # é¦–æ¬¡åˆå§‹åŒ–
                        self.take_profit_manager.initialize_capital(self._collateral_balance, is_reinit=False)
                    else:
                        # å·²æœ‰æœ¬é‡‘ï¼Œæ£€æŸ¥æ˜¯å¦æ»¡è¶³æ­¢ç›ˆæ¡ä»¶
                        if self.take_profit_manager.check_take_profit_condition(self._collateral_balance):
                            # è§¦å‘æ­¢ç›ˆ
                            self.take_profit_manager.activate(self._collateral_balance)
                            await self._execute_take_profit_reset()
                
                self.logger.info(
                    f"ğŸ’° ä½™é¢å·²æ›´æ–°: ç°è´§=${self._spot_balance:,.2f}, "
                    f"æŠµæŠ¼å“=${self._collateral_balance:,.2f}, "
                    f"è®¢å•å†»ç»“=${self._order_locked_balance:,.2f}"
                )
            else:
                all_currencies = [b.currency for b in balances]
                self.logger.warning(
                    f"âš ï¸ æœªæ‰¾åˆ°USDCä½™é¢ï¼Œæ‰€æœ‰å¸ç§: {', '.join(all_currencies) if all_currencies else '(ç©º)'}"
                )
                
        except Exception as e:
            self.logger.error(f"âŒ è·å–è´¦æˆ·ä½™é¢å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
    
    def _safe_decimal(self, value, default='0') -> Decimal:
        """å®‰å…¨è½¬æ¢ä¸ºDecimal"""
        try:
            if value is None:
                return Decimal(default)
            return Decimal(str(value))
        except:
            return Decimal(default)

